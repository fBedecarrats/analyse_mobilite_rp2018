---
title: "Analyse des données de Géovélo"
author: "Document de travail, Nantes Métropole"
date: "26/02/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Enjeux.

# Données

```{r}
library(tidyverse)
library(sf)
library(tmap)
library(tidygeocoder)
library(purrr)
library(stplanr)
remotes::install_github("statnmap/cartomisc")
library(cartomisc) # Pour des buffers sans superposition

loc_geovelo <- "data/Geovelo/"
freq_file <- "stats-fréquentation_des_axes-2021-01-01_2021-12-31.geojson"
amenag_file <- "nantes-metropole-2022-02-26-2022-02-26.geojson"
nm_inv_file <- "amenagements-cyclables-nantes-metropole-enrichis.geojson"

freq_axes_2021 <- paste0(loc_geovelo, freq_file) %>%
  read_sf() %>%
  st_transform(crs = "EPSG:27572") # on la passe en Lambert 2
amenagements <- paste0(loc_geovelo, amenag_file) %>%
  read_sf() %>%
  st_transform(crs = "EPSG:27572") # on la passe en Lambert 2
nm_inv <- paste0(loc_geovelo, nm_inv_file) %>%
  read_sf() %>%
  st_transform(crs = "EPSG:27572") # on la passe en Lambert 2

# Ajouter cartes générales
```

? Description des données

# Zoom

```{r}
# On part d'un dataframe contenant une adresse
focus_centre <- data.frame(address = "Place René Bouhier, Nantes") %>%
  geocode(address, method = "osm") %>% # on retrouve sa localisation xy
  select(long, lat) %>% # on ne garde que le xy
  as.numeric() %>% # qu'on passe en format numérique attendu par st_point
  st_point() %>% # On le spécifie en point
  st_sfc(crs = "EPSG:4326") %>% # on crée une géométrie en précisant que c'est du WSG84
  st_transform(crs = "EPSG:27572") # on la passe en Lambert 2

# On crée une boîte de 500m 
focus <- focus_centre %>% # On repart du centre
  st_buffer(dist = 250) %>% # On crée un cercle de 250m de rayon
  st_make_grid(n = 1)%>%  # On crée un carré qui l'entoure
  st_transform(crs = "EPSG:27572")

amenag_focus <- st_intersection(amenagements, focus)
freq_focus <- st_intersection(freq_axes_2021, focus)
inv_focus <- nm_inv %>%
  st_intersection(focus)
```

# Définition des zones d'influence des aménagements

```{r}
amenag_focus_buff10 <- st_buffer(amenag_focus, 10)
inv_focus_b10 <- st_buffer(inv_focus, 10)


# TODO : mettre en forme pour ajouter la fréquentation Géovélo

tm_shape(inv_focus_b10) + 
  tm_polygons(col = "green", alpha = 0.2) +
tm_shape(inv_focus) + 
  tm_lines() # + 
# tm_shape(freq_focus) + 
#   tm_lines()
```



```{r}
# La fonction regional_seas a été créée pour calculer des aires
# autour de formes. Conçue pour des buffers d'aires marines autour de régions
# (d'où le nom), elle fonctionne aussi pour des lignes
buffer_distances <- c(5, 10, 15, 20)

for (i in 1:length(buffer_distances)) {
  output_filename <- paste0("inv_amenagts_buff_", 
                            buffer_distances[i], 
                            "m_ss_superposision")
  output_path <- paste0(loc_geovelo, output_filename)
  
  if (!file.exists(paste0(output_path, ".zip"))) {
    time_start <- Sys.time()
    # On applique donc à l'ensemble des aménagements
    buffered_no_overlap <- nm_inv %>%
      regional_seas(group = "gid",
                    dist = units::set_units(buffer_distances[i], m), # buffer distance
                    density = units::set_units(1, m)) # density of points
    time_end <- Sys.time()
    duration_voro_buffer <- time_end - time_start
    st_write(buffered_no_overlap, paste0(output_path, ".shp"))
    print(output_filename)
    print(duration_voro_buffer)
    # Les temps de traitements prennent entre 3 et 8h par jeu de données
    rm(buffered_no_overlap)
  } else {
    unzip(paste0(output_path, ".zip"), exdir = "temp")
    temp <- st_read(paste0("temp/", output_filename, ".shp"))
    assign(paste0("inv_buff_", buffer_distances[i], "m"), temp)
    rm(temp)
  }
}

```


