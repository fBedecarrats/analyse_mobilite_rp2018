---
title: "Analyse des données de Géovélo"
author: "Document de travail, Nantes Métropole"
date: "26/02/2022"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE} 
# Ce bloc définit des options d'affichage pour l'ensemble du document
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

# Installation des librairies
library(tidyverse)
library(sf)
library(tmap)
library(tidygeocoder)
library(purrr)
library(stplanr)
remotes::install_github("statnmap/cartomisc")
library(cartomisc) # Pour des buffers sans superposition
library(sfnetworks)
```


# Enjeux


# Données

```{r}

loc_geovelo <- "data/Geovelo/"
freq_file <- "stats-fréquentation_des_axes-2021-01-01_2021-12-31.geojson"
amenag_file <- "nantes-metropole-2022-02-26-2022-02-26.geojson"
nm_inv_file <- "amenagements-cyclables-nantes-metropole-enrichis.geojson"

freq_axes_2021 <- paste0(loc_geovelo, freq_file) %>%
  read_sf() %>%
  st_transform(crs = "EPSG:27572") # on la passe en Lambert 2
amenagements <- paste0(loc_geovelo, amenag_file) %>%
  read_sf() %>%
  st_transform(crs = "EPSG:27572") # on la passe en Lambert 2
nm_inv <- paste0(loc_geovelo, nm_inv_file) %>%
  read_sf() %>%
  st_transform(crs = "EPSG:27572") # on la passe en Lambert 2

# Ajouter cartes générales
```

? Description des données

# Zoom

On crée une routine permettant de focaliser sur une zone spécifique afin de visualiser les aménagements cyclables (en vert) et les fréquentations d'itinéraires relevées par Géovélo (en orange) à une échelle où peut visuellement en vérifier la cohérence. 

```{r}
# On part d'un dataframe contenant une adresse
focus_centre <- data.frame(address = "Place René Bouhier, Nantes") %>%
  geocode(address, method = "osm") %>% # on retrouve sa localisation xy
  select(long, lat) %>% # on ne garde que le xy
  as.numeric() %>% # qu'on passe en format numérique attendu par st_point
  st_point() %>% # On le spécifie en point
  st_sfc(crs = "EPSG:4326") %>% # on crée une géométrie en précisant que c'est du WSG84
  st_transform(crs = "EPSG:27572") # on la passe en Lambert 2

# On crée une boîte de 500m 
focus <- focus_centre %>% # On repart du centre
  st_buffer(dist = 250) %>% # On crée un cercle de 250m de rayon
  st_make_grid(n = 1)%>%  # On crée un carré qui l'entoure
  st_transform(crs = "EPSG:27572")

amenag_focus <- st_intersection(amenagements, focus)
freq_focus <- st_intersection(freq_axes_2021, focus)
inv_focus <- nm_inv %>%
  st_intersection(focus)

tmap_mode("view")
tm_shape(inv_focus) + 
  tm_lines(col = "green")+ 
tm_shape(freq_focus) + 
  tm_lines(col = "orange") + 
tm_shape(focus) + 
  tm_borders() + 
tm_legend()

```

On observe ici qu'il y a un décalage entre la localisation des aménagements et celles des traes Geovélo. 

# Définition des zones d'influence des aménagements

Pour attribuer aux aménagements les fréquentations itinéraires relevées par Géovélo, on constitue des zones tampon autour de des aménagements et on considère que les itinéraires Géovélo qui traversent ces zones tampons transitent par l'aménagement.

Un pemier essai avec de constitution de tampons "simples" avec une distance de 10 mètres.

### Zones tampons "simples"
```{r}
amenag_focus_buff10 <- st_buffer(amenag_focus, 10)
inv_focus_b10 <- st_buffer(inv_focus, 10)


# TODO : mettre en forme pour ajouter la fréquentation Géovélo

tm_shape(inv_focus_b10) + 
  tm_polygons(col = "green", alpha = 0.1, legend.show = TRUE) +
tm_shape(inv_focus) + 
  tm_lines(col = "darkgreen", legend.show = TRUE) +
  tm_shape(focus) + 
  tm_borders()

# tm_shape(freq_focus) + 
#   tm_lines()
```

On constate que ces tampons se superposent. Cela entraîne des difficultés d'assignation des itinéraires Géovélo qui se situeraient sur une aire de superposition entre deux zones tampon d'aménagements différents : à quel aménagements les assigner dans ces cas ? Par défaut, elles seraient comptabilisées deux fois. Cette situation serait particulièrement problématiques aux carrefours, où les traces seraient comptabilisées un grand nombre de fois. 

On définit donc une méthode permettant de générer des tampons qui ne se superposent pas. Elle s'appuient sur la constitution de diagrammes de Voronoï. Cette procédure est très gourmande/chronophage en termes de calcul, car les diagrammes de Voronoï prennent comme référence des points et pas des lignes. Ici on doit décomposer chaque ligne en une série de points rapprochés, pour ensuite fusionner les polygonnes du diagramme de Voronoï appartenant à une même ligne. 

Pour éviter de re-générer ces zones tampons sans recoupement à chaque fois, on enregistre les données issues du premier calcul, et on les recharge ensuite.

```{r}
# La fonction regional_seas a été créée pour calculer des aires
# autour de formes. Conçue pour des buffers d'aires marines autour de régions
# (d'où le nom), elle fonctionne aussi pour des lignes
buffer_distances <- c(5, 10, 15, 20)


for (i in 1:length(buffer_distances)) {
  output_filename <- paste0("inv_amenagts_buff_", 
                            buffer_distances[i], 
                            "m_ss_superposision")
  output_path <- paste0(loc_geovelo, output_filename)
  
  if (!file.exists(paste0(output_path, ".zip"))) {
    time_start <- Sys.time()
    # On applique donc à l'ensemble des aménagements
    buffered_no_overlap <- nm_inv %>%
      regional_seas(group = "gid",
                    dist = units::set_units(buffer_distances[i], m), # buffer distance
                    density = units::set_units(1, m)) # density of points
    # On a utilisé une méthode toute prête (regional_seas), développé pour 
    # l'analyse des eaux territoriales, qui s'appuie sur st_buffer. 
    # Pour lefaire mieux, il faudrait reprendre le code source de regional_seas
    # et ajouter un paramètre pour la variale endCapStyle de st_buffer, afin 
    # afin de pouvoir lui passer un paramètre FLAT.
    
    time_end <- Sys.time()
    duration_voro_buffer <- time_end - time_start
    st_write(buffered_no_overlap, paste0(output_path, ".shp"))
    print(output_filename)
    print(duration_voro_buffer)
    # Les temps de traitements prennent entre 3 et 8h par jeu de données
    rm(buffered_no_overlap)
  } else {
    unzip(paste0(output_path, ".zip"), exdir = "temp")
    temp <- st_read(paste0("temp/", output_filename, ".shp"),
                    quiet = TRUE)
    st_crs(temp) <- "EPSG:27572"
    assign(paste0("inv_buff_", buffer_distances[i], "m"), temp)
    rm(temp)
  }
}

inv_buff_10m_focus <- inv_buff_10m %>%
  st_intersection(focus)

tm_shape(inv_buff_10m_focus) + 
  tm_polygons(col = "green", alpha = 0.1, legend.show = TRUE) +
tm_shape(inv_focus) + 
  tm_lines(col = "darkgreen", legend.show = TRUE) + 
tm_shape(focus) + 
  tm_borders()

```

On a bien maintenant des polygones qui ne se recoupent pas et à l'intérieur desquels on va pouvoir affecter les traces Géovélo.

# Affectation des traces Géovélo aux aménagements.

On s'appuie donc maintenant sur les zones tamon non superposées pour affecter les traces Géovélo.
- Le filaire d'aménagements, qui contiennent une donnée riche sur ces derniers : identifiant et type d'aménagement ; 
- Les zones tampons autour des aménagements, qui gardent un identifiant commun avec l'aménagement à partir duquel elles ont été générés ;
- Les traces Géovélo, qui contiennent une statistique de passage.
On visualise d'abord les traces géographiques disponibles.

```{r}
tm_shape(inv_buff_10m_focus) + 
  tm_polygons(col = "green", alpha = 0.1, legend.show = TRUE) +
tm_shape(inv_focus) + 
  tm_lines(col = "darkgreen", legend.show = TRUE) +
tm_shape(freq_focus) + 
  tm_lines(col = "orange") +
tm_shape(focus) + 
  tm_borders()
```

La procédure d'appariement entre les traces Géovélo et les aménagements peut être réalisée de la sorte :  

1. resegmentation des itinéraires Géovélo pour que les segments se situent dans les zones tampons d'aménagement et report de l'identifiant de l'aménagement correspondant dans les attributs du segment de l'itinéraire Géovélo  ;
2. Pour chaque segment Géovélo associé à une zone tampon, multiplier la fréquentation de l'itinéraire par la longueur de la trace ;
3. Somme des facteurs réalisés en 2. des itinéraires vers les zones tampon ; 
4. Report des sommes réalisées en 3. vers les aménagements associés ;
5. Pour chaque aménagement, diviser le produit calculé à l'étape 2. et sommé à l'étape 3 par la longueur de l'aménagement associé.


```{r}
# Etapes 1 à 3
freq_inv_buff_10m_focus <- freq_focus %>%
  st_intersection(inv_buff_10m_focus) %>% # Etape 1
  mutate(geovelo_paths_length = st_length(.), # Etape 2
         geovelo_frequency_factor = frequency * geovelo_paths_length) %>%
  group_by(gid) %>% # Etape 3
  summarize(paths_sum_frequency = sum(geovelo_frequency_factor, na.rm = TRUE)) %>%
  st_drop_geometry()

# Etapes 4 et 5
freq_inv_focus <- inv_focus %>% 
  left_join(freq_inv_buff_10m_focus, by = "gid") %>% # Etape 4
  mutate(facility_length = st_length(.),
         facility_frequency = paths_sum_frequency / facility_length) # Etape 5
       

tm_shape(inv_buff_10m_focus) + 
  tm_polygons(col = "green", alpha = 0.1, legend.show = TRUE) +
tm_shape(freq_inv_focus) + 
  tm_lines(col = "orange") +
tm_shape(focus) + 
  tm_borders()
```

Les tests visuels sur la carte interactive ci-dessus semble cohérents. On applique la procédure à l'ensemble des traces et aménagements.

```{r eval=FALSE}
# On a segmenté pour faciliter le débuggage en cas d'erreur 
# les étapes mettent plusieurs minutes à tourner sur le jeu complet

# Etapes 1 à 3
freq_inv_buff_10m_all_step1 <- freq_axes_2021 %>%
  st_intersection(inv_buff_10m) 
freq_inv_buff_10m_all_step2 <- freq_inv_buff_10m_all_step1 %>% # Etape 1
  mutate(geovelo_paths_length = st_length(.), # Etape 2
         geovelo_frequency_factor = frequency * geovelo_paths_length) 
freq_inv_buff_10m_all_step3 <- freq_inv_buff_10m_all_step2 %>%
  group_by(gid) %>% # Etape 3
  summarize(paths_sum_frequency = sum(geovelo_frequency_factor, na.rm = TRUE)) 
freq_inv_buff_10m_all_step3 <-  freq_inv_buff_10m_all_step3 %>%
  st_drop_geometry()

# Etapes 4 et 5
freq_inv_all <- nm_inv %>% 
  left_join(freq_inv_buff_10m_all_step3, by = "gid") %>% # Etape 4
  mutate(facility_length = st_length(.),
         facility_frequency = paths_sum_frequency / facility_length) # Etape 5

freq_inv_all %>%
  st_transform("EPSG:3947") %>%
  select(-geo_point_2d) %>%
  st_write("amenagements_cyclables_NM_freqs_Geovelo_essai_01.shp")

```

Les données générées sont extraites sous forme de Shapefile, reprojeté en CC47.

A améliorer à ce stade :

- Les extrémité des zones tampons devraient êtres carrés et pas arrondies (facile à faire mais ça mettra du temps à tourner à nouveau avec les diagrammes de Voronoï). Cf. commentaire dans le code qui indique la méthode à suivre.
- Tester la sensibilité aux tailles des zones tampons : 5m, 15m, 20m.
- Analyser les données : statistiques de fréquentation par type d'aménagement.

# Traitement des passages hors zones aménagées

A ce stade on en reste à une procédure simple d'anti-jointure pour les traces qui sont en dehors.

```{r eval=FALSE}
freq_out <- st_difference(freq_axes_2021, inv_buff_10m)

freq_out %>%
  st_transform("EPSG:3947") %>%
  select(-geo_point_2d) %>%
  st_write("frequentations_Geovelo_hors_amenagement.shp")
```

Données générées sauvegardées en shapefile reprojeté en CC47.

A améliorer sur ce volet : 

- simplification des géométries (fusionner les itinéraires parallèles et proche) : a priori en utilisant le package sfnetworks.
- représentation graphique : couleur et épaisseur des tracés pour indiquer leur importance, avec un filtre dynamique.